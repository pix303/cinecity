
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>actor: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/pix303/cinecity/pkg/actor/actor.go (97.5%)</option>
				
				<option value="file1">github.com/pix303/cinecity/pkg/actor/address.go (100.0%)</option>
				
				<option value="file2">github.com/pix303/cinecity/pkg/actor/message.go (100.0%)</option>
				
				<option value="file3">github.com/pix303/cinecity/pkg/actor/postman.go (91.7%)</option>
				
				<option value="file4">github.com/pix303/cinecity/pkg/batch/batch.go (100.0%)</option>
				
				<option value="file5">github.com/pix303/cinecity/pkg/subscriber/subscriber.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package actor

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "time"
)

var (
        ErrInboxClosed           = errors.New("actor has inbox closed")
        ErrSendWithReturnTimeout = errors.New("message with retrun has not be processed in time")
)

type Actor struct {
        address    *Address
        MessageBox chan Message
        isClosed   bool
        state      StateProcessor
}

func (a *Actor) Activate() <span class="cov8" title="1">{
        if a.IsClosed() </span><span class="cov8" title="1">{
                slog.Info("Actor activated", slog.String("address", a.address.String()))
                a.isClosed = false
                p := a.state
                if p != nil </span><span class="cov8" title="1">{
                        go a.processMessage(a.MessageBox)
                }</span>
        }
}

func (a *Actor) processMessage(inboxChan &lt;-chan Message) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                msg := &lt;-inboxChan
                a.state.Process(msg)
        }</span>
}

func (a *Actor) GetAddress() *Address <span class="cov8" title="1">{
        return a.address
}</span>

func (a *Actor) IsClosed() bool <span class="cov8" title="1">{
        return a.isClosed
}</span>

func (a *Actor) Deactivate() <span class="cov8" title="1">{
        if !a.IsClosed() </span><span class="cov8" title="1">{
                a.isClosed = true
                slog.Info("Actor deactivated", slog.String("address", a.address.String()))
        }</span>
}

func (a *Actor) Inbox(msg Message) error <span class="cov8" title="1">{
        if a.isClosed </span><span class="cov8" title="1">{
                return ErrInboxClosed
        }</span>
        <span class="cov8" title="1">a.MessageBox &lt;- msg
        return nil</span>
}

func (a *Actor) InboxAndWaitResponse(msg Message) (Message, error) <span class="cov8" title="1">{
        ctx, cancelFunc := context.WithTimeout(context.Background(), time.Duration(msg.ResponseTimeout)*time.Second)
        defer cancelFunc()

        returnChan := msg.ResponseChan

        err := a.Inbox(msg)
        if err != nil </span><span class="cov8" title="1">{
                return EmptyMessage, err
        }</span>

        <span class="cov8" title="1">select </span>{
        case returnMsg := &lt;-returnChan:<span class="cov8" title="1">
                return *returnMsg.Message, returnMsg.Err</span>
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return EmptyMessage, ErrSendWithReturnTimeout</span>
        }
}

func (a *Actor) Drop() <span class="cov8" title="1">{
        mp := a.state
        if mp != nil </span><span class="cov8" title="1">{
                mp.Shutdown()
        }</span>
        <span class="cov8" title="1">a.Deactivate()
        UnRegisterActor(a.address)
        a.address = nil
        a.state = nil
        a.MessageBox = nil</span>
}

func (a *Actor) GetState() any <span class="cov8" title="1">{
        mp := a.state
        if mp != nil </span><span class="cov8" title="1">{
                return mp.GetState()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (a *Actor) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("address: %s - isClosed: %t", a.address.String(), a.IsClosed())
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package actor

import (
        "fmt"
)

type Address struct {
        area string
        id   string
}

func NewAddress(area, id string) *Address <span class="cov8" title="1">{
        return &amp;Address{
                area,
                id,
        }
}</span>

func (this *Address) IsEqual(address *Address) bool <span class="cov8" title="1">{
        return this.area == address.area &amp;&amp; this.id == address.id
}</span>

func (this *Address) String() string <span class="cov8" title="1">{
        if this == nil </span><span class="cov8" title="1">{
                return "address nil"
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s.%s", this.area, this.id)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package actor

import "fmt"

type Message struct {
        From            *Address
        To              *Address
        Body            any
        WithResponse    bool
        ResponseChan    chan WrappedMessageWithError
        ResponseTimeout int
}

var EmptyMessage = Message{}

func NewMessage(to *Address, from *Address, body any) Message <span class="cov8" title="1">{
        return Message{
                To:              to,
                From:            from,
                Body:            body,
                WithResponse:    false,
                ResponseChan:    nil,
                ResponseTimeout: 0,
        }
}</span>

func NewMessageWithResponse(to *Address, from *Address, body any) Message <span class="cov8" title="1">{
        c := make(chan WrappedMessageWithError, 1)
        return Message{
                To:              to,
                From:            from,
                Body:            body,
                WithResponse:    true,
                ResponseChan:    c,
                ResponseTimeout: 60,
        }
}</span>

func (msg *Message) SetTimeout(value int) <span class="cov8" title="1">{
        msg.ResponseTimeout = value
}</span>

type WrappedMessageWithError struct {
        Message *Message
        Err     error
}

func NewReturnMessage(body any, originalMessage Message, err error) WrappedMessageWithError <span class="cov8" title="1">{
        m := NewMessage(
                originalMessage.From,
                originalMessage.To,
                body,
        )
        return WrappedMessageWithError{&amp;m, err}
}</span>

type AddSubscriptionMessageBody struct{}

func NewAddSubcriptionMessage(subscriberAddress *Address, notifierAddress *Address) Message <span class="cov8" title="1">{
        return Message{
                From: subscriberAddress,
                To:   notifierAddress,
                Body: AddSubscriptionMessageBody{},
        }
}</span>

type RemoveSubscriptionMessageBody struct{}

func NewRemoveSubscriptionMessage(subscriberAddress *Address, notifierAddress *Address) Message <span class="cov8" title="1">{
        return Message{
                From: subscriberAddress,
                To:   notifierAddress,
                Body: RemoveSubscriptionMessageBody{},
        }
}</span>

func NewSubscribersMessage(from *Address, body any) Message <span class="cov8" title="1">{
        return Message{
                From: from,
                Body: body,
        }
}</span>

func (this *Message) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("from: %s to: %s with body: %v", this.From.String(), this.To.String(), this.Body)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package actor

import (
        "context"
        "errors"
        "log/slog"
        "os"
        "os/signal"
        "sync"
        "syscall"
)

var (
        ErrAddressInvalid                  = errors.New("address is invalid: area or id are empty")
        ErrActorNotFound                   = errors.New("actor not found")
        ErrActorAddressAlreadyRegistered   = errors.New("actor address already registered")
        ErrInboxReturnMessageBodyTypeWrong = errors.New("return body message type is wrong")
)

type Postman struct {
        actors     map[string]*Actor
        context    context.Context
        cancelFunc func()
}

var instance Postman
var onceGuard sync.Once

func GetPostman() *Postman <span class="cov8" title="1">{
        onceGuard.Do(func() </span><span class="cov8" title="1">{
                ctx, cancFunc := context.WithCancel(context.Background())
                extCancel := make(chan os.Signal, 1)
                signal.Notify(extCancel, syscall.SIGINT, syscall.SIGTERM)

                go func() </span><span class="cov8" title="1">{
                        for </span><span class="cov8" title="1">{
                                s := &lt;-extCancel
                                switch s </span>{
                                case syscall.SIGINT, syscall.SIGTERM:<span class="cov0" title="0">
                                        ShutdownAll()</span>
                                }
                        }
                }()

                <span class="cov8" title="1">instance = Postman{
                        actors:     make(map[string]*Actor, 10),
                        context:    ctx,
                        cancelFunc: cancFunc,
                }</span>
        })
        <span class="cov8" title="1">return &amp;instance</span>
}

func (postman *Postman) GetContext() context.Context <span class="cov8" title="1">{
        return postman.context
}</span>

func RegisterActor(address *Address, processor StateProcessor) (*Actor, error) <span class="cov8" title="1">{
        if address == nil || address.area == "" || address.id == "" </span><span class="cov8" title="1">{
                return nil, ErrAddressInvalid
        }</span>

        <span class="cov8" title="1">a := Actor{
                address:    address,
                state:      processor,
                MessageBox: make(chan Message, 100),
                isClosed:   true,
        }

        p := GetPostman()
        if temp := p.actors[a.GetAddress().String()]; temp != nil </span><span class="cov8" title="1">{
                slog.Error(ErrActorAddressAlreadyRegistered.Error(), slog.String("actor-address", a.GetAddress().String()))
                return nil, ErrActorAddressAlreadyRegistered
        }</span>

        <span class="cov8" title="1">p.actors[a.GetAddress().String()] = &amp;a
        slog.Info("actor registered", slog.String("a", a.GetAddress().String()))
        a.Activate()
        return &amp;a, nil</span>
}

func UnRegisterActor(address *Address) <span class="cov8" title="1">{
        p := GetPostman()
        delete(p.actors, address.String())
}</span>

func SendMessage(msg Message) error <span class="cov8" title="1">{
        p := GetPostman()
        actor := p.actors[msg.To.String()]

        if actor == nil </span><span class="cov8" title="1">{
                slog.Error("actor not found", slog.String("actor-address", msg.To.String()))
                return ErrActorNotFound
        }</span>

        <span class="cov8" title="1">slog.Debug("actor found, sending msg", slog.String("actor-address", msg.To.String()))
        err := actor.Inbox(msg)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("actor inbox return error", slog.String("actor-address", msg.To.String()), slog.String("error", err.Error()))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func SendMessageWithResponse[T any](msg Message) (T, error) <span class="cov8" title="1">{
        p := GetPostman()
        actor := p.actors[msg.To.String()]
        if actor == nil </span><span class="cov8" title="1">{
                slog.Error("actor not found", slog.String("actor-address", msg.To.String()))
                return *new(T), ErrActorNotFound
        }</span>

        <span class="cov8" title="1">returnMsg, err := actor.InboxAndWaitResponse(msg)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error(
                        "actor inbox with response return error",
                        slog.String("actor-address", msg.To.String()),
                        slog.String("error", err.Error()),
                        slog.Any("msg", new(T)),
                )
                return *new(T), err
        }</span>

        <span class="cov8" title="1">if body, ok := returnMsg.Body.(T); ok </span><span class="cov8" title="1">{
                return body, nil
        }</span>

        <span class="cov0" title="0">return *new(T), ErrInboxReturnMessageBodyTypeWrong</span>
}

func BroadcastMessage(msg Message) <span class="cov8" title="1">{
        p := GetPostman()
        for _, a := range p.actors </span><span class="cov8" title="1">{
                err := a.Inbox(msg)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Warn("actor inbox error on broadcasting message", slog.String("actor-address", msg.To.String()), slog.String("error", err.Error()))
                }</span>
        }
}

func ShutdownAll() <span class="cov8" title="1">{
        p := GetPostman()
        for _, a := range p.actors </span><span class="cov8" title="1">{
                a.Drop()
        }</span>
        <span class="cov8" title="1">p.actors = make(map[string]*Actor)
        p.cancelFunc()</span>
}

func NumActors() int <span class="cov8" title="1">{
        p := GetPostman()
        return len(p.actors)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package batch

import (
        "log/slog"
        "sync"
        "time"

        "github.com/pix303/cinecity/pkg/actor"
)

type Batcher struct {
        messages         []actor.Message
        maxNumMessages   uint
        timeout          time.Duration
        timer            *time.Timer
        mutex            sync.Mutex
        processMessageFn func(actor.Message)
}

type MessageProcessHandler = func(msg actor.Message)

func NewBatcher(timeoutMs uint, maxMessages uint, fn MessageProcessHandler) *Batcher <span class="cov8" title="1">{
        b := Batcher{
                timeout:          time.Duration(timeoutMs) * time.Millisecond,
                messages:         make([]actor.Message, 0),
                mutex:            sync.Mutex{},
                maxNumMessages:   maxMessages,
                processMessageFn: fn,
        }
        slog.Info("Batcher created", "timeout", timeoutMs, "maxMessages", maxMessages)
        return &amp;b
}</span>

func (batcher *Batcher) Add(msg actor.Message) <span class="cov8" title="1">{
        batcher.mutex.Lock()
        if len(batcher.messages) == 0 </span><span class="cov8" title="1">{
                slog.Info("batch timer started", slog.Time("time", time.Now()), slog.Duration("timeout", batcher.timeout))
                batcher.timer = time.AfterFunc(batcher.timeout, batcher.process)
        }</span>
        <span class="cov8" title="1">batcher.messages = append(batcher.messages, msg)
        slog.Info("batch msg added", slog.Int("totalMsg", len(batcher.messages)), slog.Int("max", int(batcher.maxNumMessages)))
        batcher.mutex.Unlock()

        if len(batcher.messages) &gt;= int(batcher.maxNumMessages) </span><span class="cov8" title="1">{
                slog.Info("batch max messages reached")
                batcher.process()
        }</span>
}

func (batcher *Batcher) process() <span class="cov8" title="1">{
        slog.Info("batch process started", slog.Time("time", time.Now()))
        for _, msg := range batcher.messages </span><span class="cov8" title="1">{
                batcher.processMessageFn(msg)
        }</span>
        <span class="cov8" title="1">batcher.Stop()
        slog.Info("batch process end")</span>
}

func (batcher *Batcher) Stop() <span class="cov8" title="1">{
        batcher.timer.Stop()
        batcher.messages = make([]actor.Message, 0)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package subscriber

import (
        "log/slog"

        "github.com/pix303/cinecity/pkg/actor"
)

type SubscriptionsState struct {
        subscribers []*actor.Address
}

func NewSubscriptionsState() *SubscriptionsState <span class="cov8" title="1">{
        return &amp;SubscriptionsState{
                subscribers: make([]*actor.Address, 0),
        }
}</span>

func (state *SubscriptionsState) AddSubscription(subscriberAddress *actor.Address) <span class="cov8" title="1">{
        state.subscribers = append(state.subscribers, subscriberAddress)
}</span>

func (state *SubscriptionsState) RemoveSubscription(subscriberAddress *actor.Address) <span class="cov8" title="1">{
        for i, v := range state.subscribers </span><span class="cov8" title="1">{
                if v.IsEqual(subscriberAddress) </span><span class="cov8" title="1">{
                        state.subscribers = append(state.subscribers[:i], state.subscribers[i+1:]...)
                }</span>
        }
}

func (state *SubscriptionsState) NumSubscribers() int <span class="cov8" title="1">{
        return len(state.subscribers)
}</span>

func (state *SubscriptionsState) NotifySubscribers(msg actor.Message) <span class="cov8" title="1">{
        for _, sub := range state.subscribers </span><span class="cov8" title="1">{
                msg.To = sub
                slog.Info("sending msg to subscriber", slog.String("msg", msg.String()), slog.String("subscriber", sub.String()))
                err := actor.SendMessage(msg)
                if err != nil </span><span class="cov8" title="1">{
                        slog.Warn("error on send msg to subscribers", slog.String("msg", msg.String()), slog.String("err", err.Error()))
                }</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
